<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML Basic 1.1//EN" "http://www.w3.org/TR/xhtml-basic/xhtml-basic11.dtd">
<html>
<head>
<link rel="stylesheet" type="text/css" href="../style/style.css" />
<title>Into the Void: x86 Instruction Set Reference</title>
<link rel="icon" type="image/ico" href="../icon/siyobik.ico" />
<meta name="keywords" content="assembly,asm,programming,optimization,optimisation,c,c++,x86,pastebin,opcode,opcodes,dictionary,intel,amd,download,downloads,tutorial" />
<meta name="description" content="x86 assembly tutorials, x86 opcode reference, programming, pastebin with syntax highlighting" />
<meta name="robots" content="index, follow" />
</head>
<body>
<div class="main_container"><h1>x86 Instruction Set Reference</h1>
<script type="text/javascript">
//<![CDATA[
document.title = "CPUID: CPU Identification (x86 Instruction Set Reference)";
//]]>
</script>
<h1>CPUID</h1>
<h2>CPU Identification</h2>
<object>
<table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F A2</code></td>
<td class="grid"><code>CPUID</code></td>
<td class="grid">Returns processor identification and feature information to the EAX, EBX, ECX, and EDX registers, according to the input value entered initially in the EAX register.</td>
</tr>
</table>
</object>
<object>
<table class="box">
<tr>
<th>Description</th>
</tr>
<tr>
<td class="instruction_set_reference_box">
<p>The ID flag (bit 21) in the EFLAGS register indicates support for the CPUID instruction. If a software procedure can set and clear this flag, the processor executing the procedure supports the CPUID instruction.</p>
<p>CPUID returns processor identification and feature information in the EAX, EBX, ECX, and EDX registers. The instruction's output is dependent on the contents of the EAX register upon execution. For example, the following pseudocode loads EAX with 00H and causes CPUID to return a Maximum Return Value and the Vendor Identification String in the appropriate registers: MOV EAX, 00H CPUID. The following shows information returned, depending on the initial value loaded into the EAX register. The second table shows the maximum CPUID input value recognized for each family of IA- 32 processors on which CPUID is implemented.</p>
<p>Two types of information are returned: basic and extended function information. If a higher value entered than is valid for a particular processor, the information for the highest useful basic information value is returned. For example, if an input value of 5 is entered in EAX for a Pentium 4 processor, the information for an input value of 2 is returned. The exception to this rule is the input values that return extended function information. For a Pentium 4 processor, entering an input value of 80000005H or above returns the information for an input value of 2.</p>
<p>CPUID can be executed at any privilege level to serialize instruction execution. Serializing instruction execution guarantees that any modifications to flags, registers, and memory for previous instructions are completed before the next instruction is fetched and executed.</p>
<p>See also: &quot;Serializing Instructions&quot; in Chapter 7 of the IA-32 Intel Architecture Software Developer's Manual, Volume 3 AP-485, Intel Processor Identification and the CPUID Instruction (Order Number 241618)</p>
<h3>INPUT EAX = 0: Returns CPUID's Highest Value for Basic Processor Information and the Vendor Identification String</h3><p>When CPUID executes with EAX set to 0, the processor returns the highest value the CPUID recognizes for returning basic processor information. The value is returned in the EAX register (see second table) and is processor specific.</p>
<p>Information Returned by CPUID Instruction</p>
<div>
<table class="grid">
<caption>Basic CPUID Information</caption>
<tr><th>Initial EAX Value</th><th>Register</th><th>Information Provided about the Processor</th></tr>
<tr><td>0H</td><td>EAX</td><td>Maximum Input Value for Basic CPUID Information (see second table)</td></tr>
<tr><td>-</td><td>EBX</td><td>&quot;Genu&quot;</td></tr>
<tr><td>-</td><td>ECX</td><td>&quot;ntel&quot;</td></tr>
<tr><td>-</td><td>EDX</td><td>&quot;ineI&quot;</td></tr>
<tr><td>01H</td><td>EAX</td><td>Version Information: Type, Family, Model, and Stepping ID</td></tr>
<tr><td>-</td><td>EBX</td><td>Bits 7-0: Brand Index</td></tr>
<tr><td>-</td><td>-</td><td>Bits 15-8: CLFLUSH line size (Value . 8 = cache line size in bytes)</td></tr>
<tr><td>-</td><td>-</td><td>Bits 23-16: Number of logical processors per physical processor; two for the Pentium 4 processor supporting Hyper-Threading Technology</td></tr>
<tr><td>-</td><td>-</td><td>Bits 31-24: Local APIC ID</td></tr>
<tr><td>-</td><td>ECX</td><td>Extended Feature Information (see fourth table)</td></tr>
<tr><td>-</td><td>EDX</td><td>Feature Information (see fifth table)</td></tr>
<tr><td>02H</td><td>EAX</td><td>Cache and TLB Information (see sixth table)</td></tr>
<tr><td>-</td><td>EBX</td><td>Cache and TLB Information</td></tr>
<tr><td>-</td><td>ECX</td><td>Cache and TLB Information</td></tr>
<tr><td>-</td><td>EDX</td><td>Cache and TLB Information</td></tr>
<tr><td>03H</td><td>EAX</td><td>Reserved.</td></tr>
<tr><td>-</td><td>EBX</td><td>Reserved.</td></tr>
<tr><td>-</td><td>ECX</td><td>Bits 00-31 of 96 bit processor serial number. (Available in Pentium III processor only; otherwise, the value in this register is reserved.)</td></tr>
<tr><td>-</td><td>EDX</td><td>Bits 32-63 of 96 bit processor serial number. (Available in Pentium III processor only; otherwise, the value in this register is reserved.)</td></tr>
<tr><td>-</td><td>-</td><td>NOTE: Processor serial number (PSN) is not supported in the Pentium 4 processor or later. On all models, use the PSN flag (returned using CPUID) to check for PSN support before accessing the feature. See AP-485, Intel Processor Identification and the CPUID Instruction (Order Number 241618) for more information on PSN.</td></tr>
<tr><td>04H</td><td>EAX</td><td>Bits 4-0: Cache Type**</td></tr>
<tr><td>-</td><td>-</td><td>Bits 7-5: Cache Level (starts at 1)</td></tr>
<tr><td>-</td><td>-</td><td>Bits 8: Self Initializing cache level (does not need SW initialization)</td></tr>
<tr><td>-</td><td>-</td><td>Bits 9: Fully Associative cache</td></tr>
<tr><td>-</td><td>-</td><td>Bits 13-10: Reserved</td></tr>
<tr><td>-</td><td>-</td><td>Bits 25-14: Number of threads sharing this cache*</td></tr>
<tr><td>-</td><td>-</td><td>Bits 31-26: Number of processor cores on this die (Multicore)*</td></tr>
<tr><td>-</td><td>EBX</td><td>Bits 11-00: L = System Coherency Line Size*</td></tr>
<tr><td>-</td><td>-</td><td>Bits 21-12: P = Physical Line partitions*</td></tr>
<tr><td>-</td><td>-</td><td>Bits 31-22: W = Ways of associativity*</td></tr>
<tr><td>-</td><td>ECX</td><td>Bits 31-00: S = Number of Sets*</td></tr>
<tr><td>-</td><td>EDX</td><td>Reserved = 0</td></tr>
<tr><td>-</td><td>-</td><td>0 = Null - No more caches</td></tr>
<tr><td>-</td><td>-</td><td>1 = Data Cache</td></tr>
<tr><td>-</td><td>-</td><td>2 = Instruction Cache</td></tr>
<tr><td>-</td><td>-</td><td>3 = Unified Cache</td></tr>
<tr><td>-</td><td>-</td><td>4-31 = Reserved</td></tr>
<tr><td>-</td><td>-</td><td>NOTE: CPUID leaves &gt; 3 &lt; 80000000 are only visible when IA32_CR_MISC_ENABLES.BOOT_NT4 (bit 22) is clear (Default)</td></tr>
<tr><td>5H</td><td>EAX</td><td>Bits 15-00: Smallest monitor-line size in bytes (default is processor's monitor granularity)</td></tr>
<tr><td>-</td><td>-</td><td>Bits 31-16: Reserved = 0</td></tr>
<tr><td>-</td><td>EBX</td><td>Bits 15-00: Largest monitor-line size in bytes (default is processor's monitor granularity)</td></tr>
<tr><td>-</td><td>-</td><td>Bits 31-16: Reserved = 0</td></tr>
<tr><td>-</td><td>ECX</td><td>Reserved = 0</td></tr>
<tr><td>-</td><td>EDX</td><td>Reserved = 0</td></tr>
<tfoot>
<tr><td colspan="3">*Add one to the value in the register file to get the number. For example, the number of processor cores is EAX[31:26]+1.</td></tr>
<tr><td colspan="3">** Cache Types fields</td></tr>
</tfoot>
</table>
</div>
<div>
<table class="grid">
<caption>Extended Function CPUID Information</caption>
<tr><th>Initial EAX Value</th><th>Register</th><th>Information Provided about the Processor</th></tr>
<tr><td>80000000H</td><td>EAX</td><td>Maximum Input Value for Extended Function CPUID Information (see second table).</td></tr>
<tr><td>-</td><td>EBX</td><td>Reserved</td></tr>
<tr><td>-</td><td>ECX</td><td>Reserved</td></tr>
<tr><td>-</td><td>EDX</td><td>Reserved</td></tr>
<tr><td>80000001H</td><td>EAX</td><td>Extended Processor Signature and Extended Feature Bits. (Currently reserved)</td></tr>
<tr><td>-</td><td>EBX</td><td>Reserved</td></tr>
<tr><td>-</td><td>ECX</td><td>Reserved</td></tr>
<tr><td>-</td><td>EDX</td><td>Reserved</td></tr>
<tr><td>80000002H</td><td>EAX</td><td>Processor Brand String</td></tr>
<tr><td>-</td><td>EBX</td><td>Processor Brand String Continued</td></tr>
<tr><td>-</td><td>ECX</td><td>Processor Brand String Continued</td></tr>
<tr><td>-</td><td>EDX</td><td>Processor Brand String Continued</td></tr>
<tr><td>80000003H</td><td>EAX</td><td>Processor Brand String Continued</td></tr>
<tr><td>-</td><td>EBX</td><td>Processor Brand String Continued</td></tr>
<tr><td>-</td><td>ECX</td><td>Processor Brand String Continued</td></tr>
<tr><td>-</td><td>EDX</td><td>Processor Brand String Continued</td></tr>
<tr><td>80000004H</td><td>EAX</td><td>Processor Brand String Continued</td></tr>
<tr><td>-</td><td>EBX</td><td>Processor Brand String Continued</td></tr>
<tr><td>-</td><td>ECX</td><td>Processor Brand String Continued</td></tr>
<tr><td>-</td><td>EDX</td><td>Processor Brand String Continued</td></tr>
<tr><td>80000005H</td><td>EAX</td><td>Reserved = 0</td></tr>
<tr><td>-</td><td>EBX</td><td>Reserved = 0</td></tr>
<tr><td>-</td><td>ECX</td><td>Reserved = 0</td></tr>
<tr><td>-</td><td>EDX</td><td>Reserved = 0</td></tr>
<tr><td>80000006H</td><td>EAX</td><td>Reserved = 0</td></tr>
<tr><td>-</td><td>EBX</td><td>Reserved = 0</td></tr>
<tr><td>-</td><td>ECX</td><td>Bits 0-7: Cache Line Size</td></tr>
<tr><td>-</td><td>-</td><td>Bits 15-12: L2 Associativity</td></tr>
<tr><td>-</td><td>-</td><td>Bits 31-16: Cache size in 1K units</td></tr>
<tr><td>-</td><td>EDX</td><td>Reserved = 0</td></tr>
<tr><td>-</td><td>80000007H EAX</td><td>Reserved = 0</td></tr>
<tr><td>-</td><td>EBX</td><td>Reserved = 0</td></tr>
<tr><td>-</td><td>ECX</td><td>Reserved = 0</td></tr>
<tr><td>-</td><td>EDX</td><td>Reserved = 0</td></tr>
<tr><td>80000008H</td><td>EAX</td><td>Reserved = 0</td></tr>
<tr><td>-</td><td>EBX</td><td>Reserved = 0</td></tr>
<tr><td>-</td><td>ECX</td><td>Reserved = 0</td></tr>
<tr><td>-</td><td>EDX</td><td>Reserved = 0</td></tr>
</table>
</div>
<p>A vendor identification string is also returned in EBX, EDX, and ECX. For Intel processors, the string is &quot;GenuineIntel&quot; and is expressed: EBX = 756e6547h (* &quot;Genu&quot;, with G in the low nibble of BL *) EDX = 49656e69h (* &quot;ineI&quot;, with i in the low nibble of DL *) ECX = 6c65746eh (* &quot;ntel&quot;, with n in the low nibble of CL *)</p>
<h3>INPUT EAX = 80000000H: Returns CPUID's Highest Value for Extended Processor Information</h3><p>When CPUID executes with EAX set to 0, the processor returns the highest value the processor recognizes for returning extended processor information. The value is returned in the EAX register (see second table) and is processor specific.</p>
<div>
<table class="grid">
<caption>Highest CPUID Source Operand for IA-32 Processors</caption>
<tr><th>IA-32 Processors</th><th>Basic Information</th><th>Extended Function Information</th></tr>
<tr><td>Earlier Intel486 Processors</td><td>CPUID Not Implemented</td><td>CPUID Not Implemented</td></tr>
<tr><td>Later Intel486 Processors and Pentium Processors</td><td>01H</td><td>Not Implemented</td></tr>
<tr><td>Pentium Pro and Pentium II Processors, Intel&Atilde;�&acirc;��&Atilde;�&Acirc;&reg; Celeron&Atilde;�&Acirc;&cent;&Atilde;&cent;&acirc;�&not;&Aring;&frac34;&Atilde;�&Acirc;&cent; Processors</td><td>02H</td><td>Not Implemented</td></tr>
<tr><td>Pentium III Processors</td><td>03H</td><td>Not Implemented</td></tr>
<tr><td>Pentium 4 Processors</td><td>02H</td><td>80000004H</td></tr>
<tr><td>Intel Xeon Processors</td><td>02H</td><td>80000004H</td></tr>
<tr><td>Pentium M Processor</td><td>02H</td><td>80000004H</td></tr>
<tr><td>Pentium 4 Processor supporting Hyper-Threading Technology</td><td>05H</td><td>80000008H</td></tr>
</table>
</div>
<p>Returns Microcode Update Signature For processors that support the microcode update facility, the IA32_BIOS_SIGN_ID MSR is loaded with the update signature whenever CPUID executes. The signature is returned in the upper DWORD. For details, see Chapter 9 in the IA-32 Intel Architecture Software Developer's Manual, Volume 3.</p>
<h3>INPUT EAX = 1: Returns Model, Family, Stepping Information</h3><p>When CPUID executes with EAX set to 1, version information is returned in EAX. For example: model, family, and processor type for the first processor in the Intel Pentium 4 family is returned as follows:</p>
<ul>
<li>Model - 0000B</li>
<li>Family - 1111B</li>
<li>Processor Type - 00B</li>
</ul>
<p>See third table for available processor type values. Stepping IDs are provided as needed.</p>
<div>
<table class="grid">
<caption>Version Information Returned by CPUID in EAX</caption>
<tr><th>Bit #</th><th>Information</th></tr>
<tr><td>0-3</td><td>Stepping ID</td></tr>
<tr><td>4-7</td><td>Model</td></tr>
<tr><td>8-11</td><td>Family ID</td></tr>
<tr><td>12-13</td><td>Processor Type</td></tr>
<tr><td>14-15</td><td>Reserved</td></tr>
<tr><td>16-19</td><td>Extended Model ID</td></tr>
<tr><td>20-27</td><td>Extended Family ID</td></tr>
<tr><td>28-31</td><td>Reserved</td></tr>
</table>
</div>
<div>
<table class="grid">
<caption>Processor Type Field</caption>
<tr><th>Type</th><th>Encoding</th></tr>
<tr><td>Original OEM Processor</td><td>00B</td></tr>
<tr><td>Intel OverDrive&Atilde;�&acirc;��&Atilde;�&Acirc;&reg; Processor</td><td>01B</td></tr>
<tr><td>Dual processor (not applicable to Intel486 processors)</td><td>10B</td></tr>
<tr><td>Intel reserved</td><td>11B</td></tr>
<tfoot>
<tr><td colspan="2">NOTE See AP-485, Intel Processor Identification and the CPUID Instruction (Order Number 241618) and Chapter 14 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1, for information on identifying earlier IA-32 processors.</td></tr>
</tfoot>
</table>
</div>
<p>The Extended Family ID and Extended Model ID need be examined only if the Family ID reaches 0FH. Always display processor information as a combination of family, model, and stepping.</p>
<p>Integrate the ID fields into a display as: Displayed family = ((Extended Family ID(4-bits) &lt;&lt; 4)) (8-bits) + Family ID (4-bits zero extended to 8-bits).</p>
<p>Compute the displayed model from the Model ID and the Extended Model ID as: Displayed Model = ((Extended Model ID (4-bits) &lt;&lt; 4))(8-bits) + Model (4-bits zero extended to 8-bits)</p>
<h3>INPUT EAX = 1: Returns Additional Information in EBX</h3><p>When CPUID executes with EAX set to 1, additional information is returned to the EBX register: - Brand index (low byte of EBX) - this number provides an entry into a brand string table that contains brand strings for IA-32 processors. More information about this field is provided later in this section.</p>
<dl>
<dt>CLFLUSH instruction cache line size (second byte of EBX)</dt>
<dd>this number indicates the size of the cache line flushed with CLFLUSH instruction in 8-byte increments. This field was introduced in the Pentium 4 processor.</dd>
<dt>Local APIC ID (high byte of EBX)</dt>
<dd>this number is the 8-bit ID that is assigned to the local APIC on the processor during power up. This field was introduced in the Pentium 4 processor.</dd>
</dl>
<h3>INPUT EAX = 1: Returns Feature Information in ECX and EDX</h3><p>When CPUID executes with EAX set to 1, feature information is returned in ECX and EDX.</p>
<ul>
<li>Table four shows encodings for ECX.</li>
<li>Table five shows encodings for EDX.</li>
</ul>
<p>For all feature flags, a 1 indicates that the feature is supported. Use Intel to properly interpret feature flags.</p>
<p>NOTE Software must confirm that a processor feature is present using feature flags returned by CPUID prior to using the feature. Software should not depend on future offerings retaining all features.</p>
<div>
<table class="grid">
<caption>Extended Feature Information Returned in the ECX Register</caption>
<tr><th>Bit #</th><th>Mnemonic</th><th>Description</th></tr>
<tr><td>0</td><td>SSE3</td><td>Streaming SIMD Extensions 3 (SSE3). A value of 1 indicates the processor supports this technology.</td></tr>
<tr><td>1-2</td><td>-</td><td>Reserved</td></tr>
<tr><td>3</td><td>MONITOR</td><td>MONITOR/MWAIT. A value of 1 indicates the processor supports this feature.</td></tr>
<tr><td>4</td><td>DS-CPL</td><td>CPL Qualified Debug Store. A value of 1 indicates the processor supports the extensions to the Debug Store feature to allow for branch message storage qualified by CPL.</td></tr>
<tr><td>5-6</td><td>-</td><td>Reserved</td></tr>
<tr><td>7</td><td>EST</td><td>Enhanced Intel SpeedStep&Atilde;�&acirc;��&Atilde;�&Acirc;&reg; technology. A value of 1 indicates that the processor supports this technology.</td></tr>
<tr><td>8</td><td>TM2</td><td>Thermal Monitor 2. A value of 1 indicates whether the processor supports this technology.</td></tr>
<tr><td>9</td><td>-</td><td>Reserved</td></tr>
<tr><td>10</td><td>CNXT-ID</td><td>L1 Context ID. A value of 1 indicates the L1 data cache mode can be set to either adaptive mode or shared mode. A value of 0 indicates this feature is not supported. See definition of the IA32_MISC_ENABLE MSR Bit 24 (L1 Data Cache Context Mode) for details.</td></tr>
<tr><td>11-31</td><td>-</td><td>Reserved</td></tr>
</table>
</div>
<div>
<table class="grid">
<caption>Feature Information Returned in the EDX Register</caption>
<tr><th>Bit #</th><th>Mnemonic</th><th>Description</th></tr>
<tr><td>0</td><td>FPU</td><td>Floating Point Unit On-Chip. The processor contains an x87 FPU.</td></tr>
<tr><td>1</td><td>VME</td><td>Virtual 8086 Mode Enhancements. Virtual 8086 mode enhancements, including CR4.VME for controlling the feature, CR4.PVI for protected mode virtual interrupts, software interrupt indirection, expansion of the TSS with the software indirection bitmap, and EFLAGS.VIF and EFLAGS.VIP flags.</td></tr>
<tr><td>2</td><td>DE</td><td>Debugging Extensions. Support for I/O breakpoints, including CR4.DE for controlling the feature, and optional trapping of accesses to DR4 and DR5.</td></tr>
<tr><td>3</td><td>PSE</td><td>Page Size Extension. Large pages of size 4 MByte are supported, including CR4.PSE for controlling the feature, the defined dirty bit in PDE (Page Directory Entries), optional reserved bit trapping in CR3, PDEs, and PTEs.</td></tr>
<tr><td>4</td><td>TSC</td><td>Time Stamp Counter. The RDTSC instruction is supported, including CR4.TSD for controlling privilege.</td></tr>
<tr><td>5</td><td>MSR</td><td>Model Specific Registers RDMSR and WRMSR Instructions. The RDMSR and WRMSR instructions are supported. Some of the MSRs are implementation dependent.</td></tr>
<tr><td>6</td><td>PAE</td><td>Physical Address Extension. Physical addresses greater than 32 bits are supported: extended page table entry formats, an extra level in the page translation tables is defined, 2-MByte pages are supported instead of 4 Mbyte pages if PAE bit is 1. The actual number of address bits beyond 32 is not defined, and is implementation specific.</td></tr>
<tr><td>7</td><td>MCE</td><td>Machine Check Exception. Exception 18 is defined for Machine Checks, including CR4.MCE for controlling the feature. This feature does not define the model-specific implementations of machine-check error logging, reporting, and processor shutdowns. Machine Check exception handlers may have to depend on processor version to do model specific processing of the exception, or test for the presence of the Machine Check feature.</td></tr>
<tr><td>8</td><td>CX8</td><td>CMPXCHG8B Instruction. The compare-and-exchange 8 bytes (64 bits) instruction is supported (implicitly locked and atomic).</td></tr>
<tr><td>9</td><td>APIC</td><td>APIC On-Chip. The processor contains an Advanced Programmable Interrupt Controller (APIC), responding to memory mapped commands in the physical address range FFFE0000H to FFFE0FFFH (by default - some processors permit the APIC to be relocated).</td></tr>
<tr><td>10</td><td>-</td><td>Reserved</td></tr>
<tr><td>11</td><td>SEP</td><td>SYSENTER and SYSEXIT Instructions. The SYSENTER and SYSEXIT and associated MSRs are supported. 12 MTRR Memory Type Range Registers. MTRRs are supported. The MTRRcap MSR contains feature bits that describe what memory types are supported, how many variable MTRRs are supported, and whether fixed MTRRs are supported.</td></tr>
<tr><td>13</td><td>PGE</td><td>PTE Global Bit. The global bit in page directory entries (PDEs) and page table entries (PTEs) is supported, indicating TLB entries that are common to different processes and need not be flushed. The CR4.PGE bit controls this feature.</td></tr>
<tr><td>14</td><td>MCA</td><td>Machine Check Architecture. The Machine Check Architecture, which provides a compatible mechanism for error reporting in P6 family, Pentium 4, Intel Xeon processors, and future processors, is supported. The MCG_CAP MSR contains feature bits describing how many banks of error reporting MSRs are supported.</td></tr>
<tr><td>15</td><td>CMOV</td><td>Conditional Move Instructions. The conditional move instruction CMOV is supported. In addition, if x87 FPU is present as indicated by the CPUID.FPU feature bit, then the FCOMI and FCMOV instructions are supported</td></tr>
<tr><td>16</td><td>PAT</td><td>Page Attribute Table. Page Attribute Table is supported. This feature augments the Memory Type Range Registers (MTRRs), allowing an operating system to specify attributes of memory on a 4K granularity through a linear address.</td></tr>
<tr><td>17</td><td>PSE-36</td><td>36-Bit Page Size Extension. Extended 4-MByte pages that are capable of addressing physical memory beyond 4 GBytes are supported. This feature indicates that the upper four bits of the physical address of the 4-MByte page is encoded by bits 13-16 of the page directory entry.</td></tr>
<tr><td>18</td><td>PSN</td><td>Processor Serial Number. The processor supports the 96-bit processor identification number feature and the feature is enabled.</td></tr>
<tr><td>19</td><td>CLFSH</td><td>CLFLUSH Instruction. CLFLUSH Instruction is supported. 20 Reserved Reserved</td></tr>
<tr><td>21</td><td>DS</td><td>Debug Store. The processor supports the ability to write debug information into a memory resident buffer. This feature is used by the branch trace store (BTS) and precise event-based sampling (PEBS) facilities (see Chapter 15, Debugging and Performance Monitoring, in the IA-32 Intel Architecture Software Developer's Manual, Volume 3).</td></tr>
<tr><td>22</td><td>ACPI</td><td>Thermal Monitor and Software Controlled Clock Facilities. The processor implements internal MSRs that allow processor temperature to be monitored and processor performance to be modulated in predefined duty cycles under software control.</td></tr>
<tr><td>23</td><td>MMX</td><td>Intel MMX Technology. The processor supports the Intel MMX technology.</td></tr>
<tr><td>24</td><td>FXSR</td><td>FXSAVE and FXRSTOR Instructions. The FXSAVE and FXRSTOR instructions are supported for fast save and restore of the floating point context. Presence of this bit also indicates that CR4.OSFXSR is available for an operating system to indicate that it supports the FXSAVE and FXRSTOR instructions.</td></tr>
<tr><td>25</td><td>SSE</td><td>SSE. The processor supports the SSE extensions.</td></tr>
<tr><td>26</td><td>SSE2</td><td>SSE2. The processor supports the SSE2 extensions.</td></tr>
<tr><td>27</td><td>SS</td><td>Self Snoop. The processor supports the management of conflicting memory types by performing a snoop of its own cache structure for transactions issued to the bus.</td></tr>
<tr><td>28</td><td>HTT</td><td>Hyper-Threading Technology. The processor supports Hyper-Threading Technology.</td></tr>
<tr><td>29</td><td>TM</td><td>Thermal Monitor. The processor implements the thermal monitor automatic thermal control circuitry (TCC).</td></tr>
<tr><td>30</td><td>-</td><td>Reserved</td></tr>
<tr><td>31</td><td>PBE</td><td>Pending Break Enable. The processor supports the use of the FERR#/PBE# pin when the processor is in the stop-clock state (STPCLK# is asserted) to signal the processor that an interrupt is pending and that the processor should return to normal operation to handle the interrupt. Bit 10 (PBE enable) in the IA32_MISC_ENABLE MSR enables this capability.</td></tr>
</table>
</div>
<h3>INPUT EAX = 2: Cache and TLB Information Returned in EAX, EBX, ECX, EDX</h3><p>When CPUID executes with EAX set to 2, the processor returns information about the processor's internal caches and TLBs in the EAX, EBX, ECX, and EDX registers.</p>
<p>The encoding is as follows: - The least-significant byte in register EAX (register AL) indicates the number of times the CPUID instruction must be executed with an input value of 2 to get a complete description of the processor's caches and TLBs. The first member of the family of Pentium 4 processors will return a 1.</p>
<ul>
<li>The most significant bit (bit 31) of each register indicates whether the register contains valid information (set to 0) or is reserved (set to 1).</li>
<li>If a register contains valid information, the information is contained in 1 byte descriptors.</li>
</ul>
<p>Table six shows the encoding of these descriptors. Note that the order of descriptors in the EAX, EBX, ECX, and EDX registers is not defined; that is, specific bytes are not designated to contain descriptors for specific cache or TLB types. The descriptors may appear in any order.</p>
<div>
<table class="grid">
<caption>Encoding of Cache and TLB Descriptors</caption>
<tr><th>Descriptor</th><th>Value Cache or TLB Description</th></tr>
<tr><td>00H</td><td>Null descriptor</td></tr>
<tr><td>01H</td><td>Instruction TLB: 4 KByte Pages, 4-way set associative, 32 entries</td></tr>
<tr><td>02H</td><td>Instruction TLB: 4 MByte Pages, 4-way set associative, 2 entries</td></tr>
<tr><td>03H</td><td>Data TLB: 4KByte Pages, 4-way set associative, 64 entries</td></tr>
<tr><td>04H</td><td>Data TLB: 4MByte Pages, 4-way set associative, 8 entries</td></tr>
<tr><td>06H</td><td>1st-level instruction cache: 8 KBytes, 4-way set associative, 32 byte line size</td></tr>
<tr><td>08H</td><td>1st-level instruction cache: 16 KBytes, 4-way set associative, 32 byte line size</td></tr>
<tr><td>0AH</td><td>1st-level data cache: 8 KBytes, 2-way set associative, 32 byte line size</td></tr>
<tr><td>0CH</td><td>1st-level data cache: 16 KBytes, 4-way set associative, 32 byte line size</td></tr>
<tr><td>22H</td><td>3rd-level cache: 512 KBytes, 4-way set associative, 64 byte line size, 2 lines per sector</td></tr>
<tr><td>23H</td><td>3rd-level cache: 1 MBytes, 8-way set associative, 64 byte line size, 2 lines per sector</td></tr>
<tr><td>25H</td><td>3rd-level cache: 2 MBytes, 8-way set associative, 64 byte line size, 2 lines per sector</td></tr>
<tr><td>29H</td><td>3rd-level cache: 4M Bytes, 8-way set associative, 64 byte line size, 2 lines per sector</td></tr>
<tr><td>2CH</td><td>1st-level data cache: 32K Bytes, 8-way set associative, 64 byte line size</td></tr>
<tr><td>30H</td><td>1st-level instruction cache: 32K Bytes, 8-way set associative, 64 byte line size</td></tr>
<tr><td>40H</td><td>No 2nd-level cache or, if processor contains a valid 2nd-level cache, no 3rd-level cache</td></tr>
<tr><td>41H</td><td>2nd-level cache: 128 KBytes, 4-way set associative, 32 byte line size</td></tr>
<tr><td>42H</td><td>2nd-level cache: 256 KBytes, 4-way set associative, 32 byte line size</td></tr>
<tr><td>43H</td><td>2nd-level cache: 512 KBytes, 4-way set associative, 32 byte line size</td></tr>
<tr><td>44H</td><td>2nd-level cache: 1 MByte, 4-way set associative, 32 byte line size</td></tr>
<tr><td>45H</td><td>2nd-level cache: 2 MByte, 4-way set associative, 32 byte line size</td></tr>
<tr><td>50H</td><td>Instruction TLB: 4 KByte and 2-MByte or 4-MByte pages, 64 entries</td></tr>
<tr><td>51H</td><td>Instruction TLB: 4 KByte and 2-MByte or 4-MByte pages, 128 entries</td></tr>
<tr><td>52H</td><td>Instruction TLB: 4 KByte and 2-MByte or 4-MByte pages, 256 entries</td></tr>
<tr><td>5BH</td><td>Data TLB: 4 KByte and 4 MByte pages, 64 entries</td></tr>
<tr><td>5CH</td><td>Data TLB: 4 KByte and 4 MByte pages,128 entries</td></tr>
<tr><td>5DH</td><td>Data TLB: 4 KByte and 4 MByte pages,256 entries</td></tr>
<tr><td>60H</td><td>1st-level data cache: 16 KByte, 8-way set associative, 64 byte line size</td></tr>
<tr><td>66H</td><td>1st-level data cache: 8 KByte, 4-way set associative, 64 byte line size</td></tr>
<tr><td>67H</td><td>1st-level data cache: 16 KByte, 4-way set associative, 64 byte line size</td></tr>
<tr><td>68H</td><td>1st-level data cache: 32 KByte, 4-way set associative, 64 byte line size</td></tr>
<tr><td>70H</td><td>Trace cache: 12 K-&Atilde;�&acirc;��&Atilde;�&Acirc;&micro;op, 8-way set associative</td></tr>
<tr><td>71H</td><td>Trace cache: 16 K-&Atilde;�&acirc;��&Atilde;�&Acirc;&micro;op, 8-way set associative</td></tr>
<tr><td>72H</td><td>Trace cache: 32 K-&Atilde;�&acirc;��&Atilde;�&Acirc;&micro;op, 8-way set associative</td></tr>
<tr><td>78H</td><td>2nd-level cache: 1 MByte, 4-way set associative, 64byte line size</td></tr>
<tr><td>79H</td><td>2nd-level cache: 128 KByte, 8-way set associative, 64 byte line size, 2 lines per sector</td></tr>
<tr><td>7AH</td><td>2nd-level cache: 256 KByte, 8-way set associative, 64 byte line size, 2 lines per sector</td></tr>
<tr><td>7BH</td><td>2nd-level cache: 512 KByte, 8-way set associative, 64 byte line size, 2 lines per sector</td></tr>
<tr><td>7CH</td><td>2nd-level cache: 1 MByte, 8-way set associative, 64 byte line size, 2 lines per sector</td></tr>
<tr><td>7DH</td><td>2nd-level cache: 2 MByte, 8-way set associative, 64byte line size</td></tr>
<tr><td>7FH</td><td>2nd-level cache: 512 KByte, 2-way set associative, 64-byte line size</td></tr>
<tr><td>82H</td><td>2nd-level cache: 256 KByte, 8-way set associative, 32 byte line size</td></tr>
<tr><td>83H</td><td>2nd-level cache: 512 KByte, 8-way set associative, 32 byte line size</td></tr>
<tr><td>84H</td><td>2nd-level cache: 1 MByte, 8-way set associative, 32 byte line size</td></tr>
<tr><td>85H</td><td>2nd-level cache: 2 MByte, 8-way set associative, 32 byte line size</td></tr>
<tr><td>86H</td><td>2nd-level cache: 512 KByte, 4-way set associative, 64 byte line size</td></tr>
<tr><td>87H</td><td>2nd-level cache: 1 MByte, 8-way set associative, 64 byte line size</td></tr>
<tr><td>B0H</td><td>Instruction TLB: 4 KByte Pages, 4-way set associative, 128 entries</td></tr>
<tr><td>B3H</td><td>Data TLB: 4 KByte Pages, 4-way set associative, 128 entries</td></tr>
<tr><td>F0H</td><td>64-Byte Prefetching</td></tr>
<tr><td>F1H</td><td>128-Byte Prefetching</td></tr>
</table>
</div>
<p>Example of Cache and TLB Interpretation The first member of the family of Pentium 4 processors returns the following information about caches and TLBs when the CPUID executes with an input value of 2: EAX 66 5B 50 01H EBX 0H ECX 0H EDX 00 7A 70 00H Which means: - The least-significant byte (byte 0) of register EAX is set to 01H. This indicates that CPUID needs to be executed once with an input value of 2 to retrieve complete information about caches and TLBs.</p>
<ul>
<li>The most-significant bit of all four registers (EAX, EBX, ECX, and EDX) is set to 0, indicating that each register contains valid 1-byte descriptors.</li>
<li>Bytes 1, 2, and 3 of register EAX indicate that the processor has: 50H -&gt; a 64-entry instruction TLB, for mapping 4-KByte and 2-MByte or 4-MByte pages;	5BH -&gt; a 64-entry data TLB, for mapping 4-KByte and 4-MByte pages; 66H -&gt; an 8-KByte 1st level data cache, 4-way set associative, with a 64-Byte cache line size.</li>
<li>The descriptors in registers EBX and ECX are valid, but contain NULL descriptors.</li>
<li>Bytes 0, 1, 2, and 3 of register EDX indicate that the processor has: 00H -&gt; NULL descriptor; 70H -&gt; a 12-KByte 1st level code cache, 4-way set associative, with a 64-byte cache line size; 7AH -&gt; a 256-KByte 2nd level cache, 8-way set associative, with a sectored, 64-byte cache line size; 00H -&gt; NULL descriptor.</li>
</ul>
<h3>Methods for returning branding information</h3><p>Use the following techniques to access branding information: 1. Processor brand string method; this method also returns the processor's maximum operating frequency 2. Processor brand index; this method uses a software supplied brand string table.</p>
<p>These two methods are discussed in the following sections. For methods that are available in early processors, see Section: &quot;Identification of Earlier IA-32 Processors&quot; in Chapter 14 of the IA-32 Intel Architecture Software Developer's Manual, Volume 1.</p>
<p>The Processor Brand String Method describes the algorithm used for detection of the brand string. Processor brand identification software should execute this algorithm on all IA-32 architecture compatible processors.</p>
<p>This method (introduced with Pentium 4 processors) returns an ASCII brand identification string and the maximum operating frequency of the processor to the EAX, EBX, ECX, and EDX registers.</p>
<h3>Determination of Support for the Processor Brand String</h3><pre>EAX = 1
CPUID
IF (EAX &gt;= 080000004H)
THEN
	* Processor Brand String Supported *
ELSE
	* Processor Brand String Not Supported *
FI;
</pre>
<p>How Brand Strings Work To use the brand string method, execute CPUID with EAX input of 8000002H through 80000004H. For each input value, CPUID returns 16 ASCII characters using EAX, EBX, ECX, and EDX. The returned string will be NULL terminated.</p>
<p>Table seven shows the brand string that is returned by the first processor in the Pentium 4 processor family.</p>
<div>
<table class="grid">
<caption>Processor Brand String Returned with Pentium 4 Processor</caption>
<tr><th>EAX Input Value</th><th>Return Values</th><th>ASCII Equivalent</th></tr>
<tr><td>80000002H</td><td>EAX = 20202020H</td><td>&quot; &quot;</td></tr>
<tr><td>-</td><td>EBX = 20202020H</td><td>&quot; &quot;</td></tr>
<tr><td>-</td><td>ECX = 20202020H</td><td>&quot; &quot;</td></tr>
<tr><td>-</td><td>EDX = 6E492020H</td><td>&quot;nI &quot;</td></tr>
<tr><td>80000003H</td><td>EAX = 286C6574H</td><td>&quot;(let&quot;</td></tr>
<tr><td>-</td><td>EBX = 50202952H</td><td>&quot;P )R&quot;</td></tr>
<tr><td>-</td><td>ECX = 69746E65H</td><td>&quot;itne&quot;</td></tr>
<tr><td>-</td><td>EDX = 52286D75H</td><td>&quot;R(mu&quot;</td></tr>
<tr><td>80000004H</td><td>EAX = 20342029H</td><td>&quot; 4 )&quot;</td></tr>
<tr><td>-</td><td>EBX = 20555043H</td><td>&quot; UPC&quot;</td></tr>
<tr><td>-</td><td>ECX = 30303531H</td><td>&quot;0051&quot;</td></tr>
<tr><td>-</td><td>EDX = 007A484DH</td><td>&quot; zHM&quot;</td></tr>
</table>
</div>
<p>Extracting the Maximum Processor Frequency from Brand Strings provides an algorithm which software can use to extract the maximum processor operating frequency from the processor brand string.</p>
<p>NOTE When a frequency is given in a brand string, it is the maximum qualified frequency of the processor, not the frequency at which the processor is currently running.</p>
<h3>Algorithm for Extracting Maximum Processor Frequency</h3><pre>Scan &quot;Brand String&quot; in Reverse Byte Order for (&quot;zHM&quot;, &quot;zHG&quot;, &quot;zHT&quot;)
IF Substring Matched
	SWITCH Substring
		CASE &quot;zHM&quot;: Multiplier = 10^6
		CASE &quot;zHG&quot;: Multiplier = 10^9
		CASE &quot;zHT&quot;: Multiplier = 10^12
	Scan Digits Until Blank In Reverse Order
	Freq = Reverse Digits To Decimal Value
	(* &quot;Freq&quot; = XY.Z if Digits = &quot;Z.YX&quot; *)
	Max. Qualifed Frequency = &quot;Freq&quot; x &quot;Multiplier&quot;
ELSE Report Error
</pre>
<p>The Processor Brand Index Method The brand index method (introduced with Pentium III Xeon processors) provides an entry point into a brand identification table that is maintained in memory by system software and is accessible from system- and user-level code. In this table, each brand index is associate with an ASCII brand identification string that identifies the official Intel family and model number of a processor.</p>
<p>When CPUID executes with EAX set to 1, the processor returns a brand index to the low byte in EBX. Software can then use this index to locate the brand identification string for the processor in the brand identification table. The first entry (brand index 0) in this table is reserved, allowing for backward compatibility with processors that do not support the brand identification feature.</p>
<p>Table eight shows brand indices that have identification strings associated with them.</p>
<div>
<table class="grid">
<caption>Mapping of Brand Indices and IA-32 Processor Brand Strings</caption>
<tr><th>Brand Index</th><th>Brand String</th></tr>
<tr><td>00H</td><td>This processor does not support the brand identification feature</td></tr>
<tr><td>01H</td><td>Intel(R) Celeron(R) processor</td></tr>
<tr><td>02H</td><td>Intel(R) Pentium(R) III processor</td></tr>
<tr><td>03H</td><td>Intel(R) Pentium(R) III XeonTM processor; If processor signature = 000006B1h, then Intel(R) Celeron(R) processor</td></tr>
<tr><td>04H</td><td>Intel(R) Pentium(R) III processor</td></tr>
<tr><td>06H</td><td>Mobile Intel(R) Pentium(R) III processor-M</td></tr>
<tr><td>07H</td><td>Mobile Intel(R) Celeron(R) processor</td></tr>
<tr><td>08H</td><td>Intel(R) Pentium(R) 4 processor</td></tr>
<tr><td>09H</td><td>Intel(R) Pentium(R) 4 processor</td></tr>
<tr><td>0AH</td><td>Intel(R) Celeron(R) processor</td></tr>
<tr><td>0BH</td><td>Intel(R) Xeon(TM) processor; If processor signature = 00000F13h, then Intel(R) Xeon(TM) processor MP</td></tr>
<tr><td>0CH</td><td>Intel(R) Xeon(TM) processor MP</td></tr>
<tr><td>0EH</td><td>Mobile Intel(R) Pentium(R) 4 processor-M; If processor signature = 00000F13h, then Intel(R) Xeon(TM) processor</td></tr>
<tr><td>0FH</td><td>Mobile Intel(R) Celeron(R) processor</td></tr>
<tr><td>11H</td><td>Mobile Genuine Intel(R) processor</td></tr>
<tr><td>12H</td><td>Intel(R) Celeron(R) M processor</td></tr>
<tr><td>13H</td><td>Mobile Intel(R) Celeron(R) processor</td></tr>
<tr><td>14H</td><td>Intel(R) Celeron(R) processor</td></tr>
<tr><td>15H</td><td>Mobile Genuine Intel(R) processor</td></tr>
<tr><td>16H</td><td>Intel(R) Pentium(R) M processor</td></tr>
<tr><td>17H</td><td>Mobile Intel(R) Celeron(R) processor</td></tr>
<tr><td>18H-0FFH</td><td>RESERVED</td></tr>
</table>
</div>
</td>
</tr>
</table>
</object>
<object>
<table class="box">
<tr>
<th>Operation</th>
</tr>
<tr>
<td class="instruction_set_reference_box">
<pre><span class="keyword">switch</span><span class="operator">(</span>EAX<span class="operator">)</span> {
	<span class="keyword">case</span> <span class="number">0</span><span class="operator">:</span>
		EAX <span class="operator">=</span> HighestCPUIDInput<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//highest basic function input value understood by CPUID</span>
		EBX <span class="operator">=</span> VendorIdentificationString<span class="operator">[</span><span class="number">0..3</span><span class="operator">]</span><span class="operator">;</span>
		EDX <span class="operator">=</span> VendorIdentificationString<span class="operator">[</span><span class="number">4..7</span><span class="operator">]</span><span class="operator">;</span>
		ECX <span class="operator">=</span> VendorIdentificationString<span class="operator">[</span><span class="number">8..11</span><span class="operator">]</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> <span class="number">1</span><span class="operator">:</span>
		EAX<span class="operator">[</span><span class="number">0..3</span><span class="operator">]</span> <span class="operator">=</span> SteppingID<span class="operator">;</span>
		EAX<span class="operator">[</span><span class="number">4..7</span><span class="operator">]</span> <span class="operator">=</span> Model<span class="operator">;</span>
		EAX<span class="operator">[</span><span class="number">8..11</span><span class="operator">]</span> <span class="operator">=</span> Family<span class="operator">;</span>
		EAX<span class="operator">[</span><span class="number">12..13</span><span class="operator">]</span> <span class="operator">=</span> ProcessorType<span class="operator">;</span>
		EAX<span class="operator">[</span><span class="number">14..15</span><span class="operator">]</span> <span class="operator">=</span> Reserved<span class="operator">;</span>
		EAX<span class="operator">[</span><span class="number">16..19</span><span class="operator">]</span> <span class="operator">=</span> ExtendedModel<span class="operator">;</span>
		EAX<span class="operator">[</span><span class="number">20..23</span><span class="operator">]</span> <span class="operator">=</span> ExtendedFamily<span class="operator">;</span>
		EAX<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">=</span> Reserved<span class="operator">;</span>
		EBX<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">=</span> BrandIndex<span class="operator">;</span>
		EBX<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">=</span> CLFLUSHLineSize<span class="operator">;</span>
		EBX<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">=</span> Reserved<span class="operator">;</span>
		EBX<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">=</span> InitialAPICID<span class="operator">;</span>
		ECX <span class="operator">=</span> ExtendedFeatureFlags<span class="operator">;</span>
		EDX <span class="operator">=</span> FeatureFlags<span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> <span class="number">2</span><span class="operator">:</span>
		EAX <span class="operator">=</span> CacheAndTLBInformation<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
		EBX <span class="operator">=</span> CacheAndTLBInformation<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//0</span>
		ECX <span class="operator">=</span> CacheAndTLBInformation<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//0</span>
		EDX <span class="operator">=</span> CacheAndTLBInformation<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> <span class="number">3</span><span class="operator">:</span>
		EAX <span class="operator">=</span> Reserved<span class="operator">;</span>
		EBX <span class="operator">=</span> Reserved<span class="operator">;</span>
<span class="preprocessor">#ifdef PentiumIII</span>
		ECX <span class="operator">=</span> ProcessorSerialNumber<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">;</span>
		EDX <span class="operator">=</span> ProcessorSerialNumber<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span><span class="operator">;</span>
<span class="preprocessor">#else</span>
		ECX <span class="operator">=</span> Reserved<span class="operator">;</span>
		EDX <span class="operator">=</span> Reserved<span class="operator">;</span>
<span class="preprocessor">#endif</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> <span class="number">4</span><span class="operator">:</span>
		EAX <span class="operator">=</span> DeterministicCacheParametersLeaf<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
		EBX <span class="operator">=</span> DeterministicCacheParametersLeaf<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
		ECX <span class="operator">=</span> DeterministicCacheParametersLeaf<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
		EDX <span class="operator">=</span> DeterministicCacheParametersLeaf<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> <span class="number">5</span><span class="operator">:</span>
		EAX <span class="operator">=</span> MONITORMWAITLeaf<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
		EBX <span class="operator">=</span> MONITORMWAITLeaf<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
		ECX <span class="operator">=</span> MONITORMWAITLeaf<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
		EDX <span class="operator">=</span> MONITORMWAITLeaf<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> <span class="number">0x80000000</span><span class="operator">:</span>
		EAX <span class="operator">=</span> HighestExtendedCPUIDInput<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//highest extended function input value understood by CPUID</span>
		EBX <span class="operator">=</span> Reserved<span class="operator">;</span>
		ECX <span class="operator">=</span> Reserved<span class="operator">;</span>
		EDX <span class="operator">=</span> Reserved<span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> <span class="number">0x80000001</span><span class="operator">:</span>
		EAX <span class="operator">=</span> ExtendedProcessorFeatureSignature<span class="operator">;</span> <span class="comment">//Currently Reserved</span>
		EBX <span class="operator">=</span> Reserved<span class="operator">;</span>
		ECX <span class="operator">=</span> Reserved<span class="operator">;</span>
		EDX <span class="operator">=</span> Reserved<span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> <span class="number">0x80000002</span><span class="operator">:</span>
		EAX <span class="operator">=</span> ProcessorBrandString<span class="operator">[</span><span class="number">0..3</span><span class="operator">]</span><span class="operator">;</span>
		EBX <span class="operator">=</span> ProcessorBrandString<span class="operator">[</span><span class="number">4..7</span><span class="operator">]</span><span class="operator">;</span>
		ECX <span class="operator">=</span> ProcessorBrandString<span class="operator">[</span><span class="number">8..11</span><span class="operator">]</span><span class="operator">;</span>
		EDX <span class="operator">=</span> ProcessorBrandString<span class="operator">[</span><span class="number">12..15</span><span class="operator">]</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> <span class="number">0x80000003</span><span class="operator">:</span>
		EAX <span class="operator">=</span> ProcessorBrandString<span class="operator">[</span><span class="number">16..19</span><span class="operator">]</span><span class="operator">;</span>
		EBX <span class="operator">=</span> ProcessorBrandString<span class="operator">[</span><span class="number">20..23</span><span class="operator">]</span><span class="operator">;</span>
		ECX <span class="operator">=</span> ProcessorBrandString<span class="operator">[</span><span class="number">24..27</span><span class="operator">]</span><span class="operator">;</span>
		EDX <span class="operator">=</span> ProcessorBrandString<span class="operator">[</span><span class="number">28..31</span><span class="operator">]</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>		
	<span class="keyword">case</span> <span class="number">0x80000004</span><span class="operator">:</span>
		EAX <span class="operator">=</span> Reserved<span class="operator">;</span>
		EBX <span class="operator">=</span> Reserved<span class="operator">;</span>
		ECX <span class="operator">=</span> Reserved<span class="operator">;</span>
		EDX <span class="operator">=</span> Reserved<span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> <span class="number">0x80000006</span><span class="operator">:</span>
		EAX <span class="operator">=</span> Reserved<span class="operator">;</span>
		EBX <span class="operator">=</span> Reserved<span class="operator">;</span>
		ECX <span class="operator">=</span> CacheInformation<span class="operator">;</span>
		EDX <span class="operator">=</span> Reserved<span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> <span class="number">0x80000007</span><span class="operator">:</span>
		EAX <span class="operator">=</span> Reserved<span class="operator">;</span>
		EBX <span class="operator">=</span> Reserved<span class="operator">;</span>
		ECX <span class="operator">=</span> Reserved<span class="operator">;</span>
		EDX <span class="operator">=</span> Reserved<span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> <span class="number">0x80000008</span><span class="operator">:</span>
		EAX <span class="operator">=</span> Reserved<span class="operator">;</span>
		EBX <span class="operator">=</span> Reserved<span class="operator">;</span>
		ECX <span class="operator">=</span> Reserved<span class="operator">;</span>
		EDX <span class="operator">=</span> Reserved<span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">default</span><span class="operator">:</span> <span class="comment">//EAX > highest value recognized by CPUID</span>
		<span class="comment">//undefined</span>
		EAX <span class="operator">=</span> Reserved<span class="operator">;</span>
		EBX <span class="operator">=</span> Reserved<span class="operator">;</span>
		ECX <span class="operator">=</span> Reserved<span class="operator">;</span>
		EDX <span class="operator">=</span> Reserved<span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
}
</pre>
</td>
</tr>
</table>
</object>
<object>
<table class="box">
<tr>
<th>Flags affected</th>
</tr>
<tr>
<td class="instruction_set_reference_box">
<p>None.
</p>
</td>
</tr>
</table>
</object>
<object>
<table class="box">
<tr>
<th>IA-32 Architecture Compatibility</th>
</tr>
<tr>
<td class="instruction_set_reference_box">
<p>CPUID is not supported in early models of the Intel486 processor or in any IA-32 processor earlier than the Intel486 processor.
</p>
</td>
</tr>
</table>
</object>
<object>
<table class="box">
<tr>
<th>Exceptions</th>
</tr>
<tr>
<td class="instruction_set_reference_box">
None.
NOTE In earlier IA-32 processors that do not support the CPUID instruction, execution of the instruction results in an invalid opcode (#UD) exception being generated.
</td>
</tr>
</table>
</object>
</div>
</body>
</html>
